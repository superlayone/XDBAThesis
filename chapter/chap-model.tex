
\chapter{基于贝叶斯分类的多算法混合虚拟资源调度系统}
\label{chap:model}
\section{$BMVS^2$的设计}
\subsection{系统结构设计}
在科学技术的发展史上，系统工程与其他技术科学一样，它的产生和发展主要由需求所驱动。一个系统都有着它特定的架构，在该架构下，根据预定义的规则执行着任务流。

系统环境的复杂性是以其变化的不确定性和难以发现为主的，虚拟环境下，资源池有着从物理主机虚拟出来的庞大的资源，如虚拟CPU、虚拟内存等，而用户的需求也是变化不定的。在传统的虚拟机资源调度系统里，往往只有一种调度算法，或者一个特定时期的版本只有一种当时比较合理的算法，使用这种算法往往限制很多条件。而对于目前趋于更加复杂的管理与决策系统，必须把这些动态变化的因素作为一个整体来进行分析。

对于管理的任务或者调度的对象，以往都是着眼于用数学语言进行描述，而这种描述有时是不准确的。实际上，一个任务行为的确定，需要结合以往的历史信息，进行分类，然后选择一种当前最佳的算法。

面对复杂的环境和多变的请求，用传统的理论和方法愈加显得捉襟见肘，这是因为：

\begin{enumerate}
  \item 传统的系统调度是建立在精确的模型之上的。而模型到数学的抽象，一方面虽然使问题得到简化，但有时也丢失了一些信息，或者对模型进行了某些限制。
  \item 传统的调度系统一旦完成，在一段时间内的算法是固定的，并不能很好的适应多变的请求。
  \item 传统的决策支持是在一个特定算法下，处理的能力有限，它不能感知，也丢弃了一些有用的历史信息，放弃了对这些信息进行融合、分析和推理，也就没有自我适应、自学习和自组织的能力。
\end{enumerate}

基于此，本文提出了一种基于贝叶斯分类的多算法混合虚拟资源调度系统（Bayes-classifier based Mixed-algorithm Virtual-resources Scheduling System ，简称$BMVS^2$），它的架构如图\ref{sys}所示：
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.8\textwidth]{sys}
 \caption{$BMVS^2$的架构}
 \label{sys}
\end{figure}
\subsection{系统的工作流程设计}
根据所设计的虚拟资源计算平台调度系统的结构，该系统的执行流程如图\ref{modelflow}所示。

整个调度系统按照执行的过程主要分为两部分，一次决策过程和VM执行相关信息的搜集，分别如图\ref{modelflow} 的（a）和（b）所示。

\begin{enumerate}
  \item 一次决策过程

  外界向系统提出请求，分配到每个VM上执行，监控器会获得运行过程中VM的任务请求状态信息，而预测器会从监控器获得这些信息，进行简单的处理后交由分类器进行分类。分类器使用Bayes决策，首次使用由于没有先验概率，故随机做出一个决策（或者首次使用训练收据集进行训练，获得先验概率），之后交由预测器，预测器会根据已有的算法模块，评价这次决策并选择最佳的算法进行调度，选择好算法后通知Scheduler进行具体的调度。将不同的任务请求分成不同的组态，在各个不同的组态内执行相应的分配策略。其具体的过程相当于在图\ref{request}中的各种分类线上找到一条合理的，以形成一个更好的组态。
  \item 信息保留

  一次决策过程的具体实施，必然会表现出性能的差异，通过收集这些信息，更改先验概率、分类标签等，预测器可以在下一次分类做出更加合理的决策。
\end{enumerate}
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.8\textwidth]{modelflow}
 \caption{$BMVS^2$的工作流程}
 \label{modelflow}
\end{figure}
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.8\textwidth]{request}
 \caption{$BMVS^2$的任务请求重组机制}
 \label{request}
\end{figure}
\section{$BMVS^2$的分析}
\subsection{系统结构分析}
结合$BMVS^2$的架构图，该结构的各个部分的分析如下：

\begin{enumerate}
  \item 硬件层

  硬件层是整个架构的基础，它们组成一个集群式的物理资源层，这些硬件资源可能是集中式的多台物理主机，也可能是分布在不同地域的分布式主机。
  \item 虚拟层

  该层的作用是提供对硬件进行虚拟化，包括CPU、内存、I/O、块设备等等，同时，监控器也处于该层，监控位于该层上的VM 运行使用情况、任务请求情况，以及硬件的资源情况。
  \item 知识发现

  虚拟化系统发展至今，已经出现了众多的调度算法，不乏优秀的资源调度策略，但是基本上是基于受限的数学模型抽象，拘泥于确定的模型。而随着智能系统的发展，虚拟资源调度系统下一步也会朝着更加智能的方向发展，而作为具有学习能力的系统，预测感知、分类决策、数据库模块是必不可少的。它们能够结合历史信息对当前环境状态做出一个最佳的估计。

  \item 算法模块

  本系统挂载多个算法模块，由于目前已有的算法都有着特定的应用背景，比如针对CPU密集、I/O密集、计算公平、存储优先等等，而我们可以根据预测分类机制对任务请求实施组态的分类，每个组实施不同的分配策略，以达到当前的最佳期望。
  \item Scheduler
  
  调度器是建立在分类基础之上的一个模块，在分类完成后，调度器完成对任务的划分，部署到不同的VM上，而具体到每个VM上的调度则由VM上的调度算法完成。
  \item 反馈
  
  输出的决策产生的影响直接或间接的反馈到决策输入端，这样便形成了一个闭环控制系统。为了实现闭环反馈控制，必须对决策产生的影响进行评价，由评价因子决定影响的优劣。
\end{enumerate}

$BMVS^2$有着很明确的模块化思想，将所需的要素组合在一起，在特定的层上构成了一个具有特定功能的子系统，子系统作为通用性的模块与其它模块要素进行组合。模块化设计是绿色设计方法之一，具有高内聚、低耦合的特点，它已经从理念转变为较成熟的设计方法。将绿色设计思想与模块化设计方法结合起来，可以同时满足产品的功能属性和环境属性，同时满足后续的更改、添加、删除等等。

$BMVS^2$核心模块是预测分类模块，数据挖掘的任务就是从其目标上进行分类，为此，有如下定义：

\begin{defn}
数据挖掘就是对观测到的数据集（一般来讲是很庞大的）进行分析，目的是发现未知的关系和以数据拥有者可以理解并对其有价值的新颖方式来总结数据。
\end{defn}
带有知识发现的数据挖掘就是从目标上进行分类\cite{data}，分类是数据挖掘中非常重要的一种技术。不同的方法构造的分类器也不同，主要有决策树、贝叶斯、K-临近等等。其中贝叶斯分类器就是使用概率理论，以贝叶斯定理为基础，建立分类模型的一种学习方式。此外，分类器不会独立存在，大多会伴随\textbf{知识发现}（Knowledge Discovery，简称KD）而存在。

分类和预测是两个概念，两种方法都是数据挖掘中对数据分析的方法，但分类不等同于预测。所以在提出架构的时候将两者分离。

在具有模式的完整统计知识条件下，贝叶斯分类器是按照贝叶斯决策理论进行设计的一种最优分类器。分类器是对每一个输入模式赋予一个类别名称的模块，而贝叶斯分类器是各种分类器中分类错误概率最小或者在预先给定代价的情况下平均风险最小的分类器\cite{MinErrBayes}。它的设计方法是一种最基本的统计分类方法。

%从控制论角度来分析，本系统符合控制论系统的特征：

%\begin{enumerate}
%  \item 有一个预定的稳定状态或平衡状态。例如本系统中一次决策后，系统按产生的算法进入运行态。
%  \item 从外部环境到内部有一种信息的传递。例如本系统中，外界提交请求，监控器获取数据，决策支持模块给出策略。
%  \item 这种系统具有一种专门设计用来校正行为的装置。例如本系统的反馈、知识发现、存储交换机制。
%  \item 这种系统为了在不断变化的环境中维持自身的稳定，内部具有自动调节的机制，换言之，控制系统都是一种动态系统。本系统是一种动态的带有知识学习能力的动态系统。
%\end{enumerate}
\subsection{决策分类模块的理论分析}
Saridis认为智能控制是数学与语言描述和用于系统与过程的算法之间的结合\cite{Saridis}。为了解决资源调度问题，希望在调度的时候能够带有数据挖掘和机器学习的能力。

具有数据挖掘和机器学习的模块主要功能是：

\begin{itemize}
  \item 接受上级数据并对此进行推理

  推理将不同的评价标准与所收集的数据结合，并从概率上评估一个决策。
  \item 规划

  主要是对动作进行操作，根据所选择的策略实现调度。为了计算概率，要用到先验概率、后验概率和最大似然估计等概念。
  \item 决策

  选择一个最佳的可能的决策。
  \item 反馈

  在完成一次决策后进行评估，通过学习更新概率。
  \item 存储交换

  更新存储在数据库中的信息。
\end{itemize}

为了从数学上给出原型系统的验证，本文首先对相关概念作出定义，然后对各个模块进行描述。

对于统计推理分类来说，数据分布的信息可以通过分析服从该分布的数据推理而来。给定一个数据集$X=\{x_1,x_2,\dots,x_n\}$, 从而发现派生出这个数据集的总体分部属性。定理3.1中的贝叶斯法则，是一种以给定的数据集为依据或输入来估计某种属性的可能性方法。假定$h_1$和$h_2$是两个假设，则必有一个成立，但是不能同时成立。又假设$x_i$是可观测事件。

\begin{thm}
贝叶斯定理
\end{thm}
\begin{equation}
P(h_1|x_i)=\frac{P(x_i|h_1)P(h_1)}{P(x_i|h_1)P(h_1)+P(x_i|h_2)P(h_2)}
\end{equation}

这里$P(h_1|x_i)$为\textbf{后验概率}，而$P(h_1)$是假设$h_1$的\textbf{先验概率}。$P(x_i)$是出现$x_i$的概率。$P(x_i|h_1)$是$x_i$元组满足给定假设的条件概率。

当存在m种不同的假设时，有：
\begin{equation}
P(x_i)=\sum_{j=1}^m P(x_i|h_j)P(h_j)
\end{equation}

因此，有
\begin{equation}
\label{eq:proba}
P(h_1|x_i)=\frac{P(x_i|h_1)P(h_1)}{P(x_i)}
\end{equation}

贝叶斯定理允许为给定的一个数据值指定一个假设的概率值$P(h_j|x_i)$。在实际问题中，$x_i$可以是属性值，也可以是其它数据标签。$h_i$可以是属性值、属性值的集合（如范围），甚至是一些属性值的组合。正如文献\cite{KLR98}所讨论的，有三种方法可以解决分类问题，即指定边界、利用概率分布、利用后验概率。而贝叶斯分类恰好符合这些方法，从而可以合理的进行分类问题的解决。

定义\ref{defclassification}给出了分类问题的定义。
\begin{defn}
\label{defclassification}
给定一个由元组（条目，记录）组成的数据$D=\{t_1,t_2,\dots,t_n\}$和一个类别集合$C=\{C_1,C_2,\dots,C_m\}$，\textbf{分类问题}是指定一个映射$f:D\rightarrow C$，其中每个元组$t_i$被分配到一个类中，一个\textbf{类$C_j$}精确地包含了被映射到其中的元组，即$C_j$=$\{t_i|f(t_i)=C_j,1\leq i \leq n,且t_i\in D \}$。
\end{defn}

对一个目标元组进行分类时，需要利用从训练集中产生的条件概率和先验概率进行预测。这就需要将元组中不同的属性值对预测所起的作用组合起来。假设元组$t_i$有P个独立的属性值$\{x_{i1},x_{i2},\dots,x_{ip}\}$。对于每个类$C_j$和属性$x_{ik}$，由描述阶段可得到$P(x_{ik}|C_j)$，进而可以估计出$P(t_j|C_j)$，即
\begin{equation}
P(t_i|C_j)=\prod_{k=1}^p P(x_{ik}|C_j)
\end{equation}

Algorithm\ref{alg:Bayes}和\ref{alg:Prob}是分类决策的伪代码：

\begin{algorithm}[htb]                  %算法的开始
\caption{贝叶斯分类算法}                %算法的标题
\label{alg:Bayes}                       %给算法一个标签，这样方便在文中对算法的引用
\begin{algorithmic}[1]                  %不知[1]是干嘛的？
\REQUIRE ~~\\                           %算法的输入参数：Initialization
    $X=\{x_1,x_2,\dots,x_n\}$   \hskip 30pt $\rhd$ 待分类项\\
    $C=\{C_1,C_2,\dots,C_m\}$   \hskip 30pt $\rhd$ 已有类别
\ENSURE ~~\\                           %算法的迭代：Iteration
    %Ensemble of classifiers on the current batch,  $E_n$;
\WHILE    {$C_j$ and $j\leq m$}
   \STATE Compute $P(C_j|x_i)$;
\ENDWHILE              %算法的返回值
\IF{$P(C_k|X)$=max\{$P(C_1|X)$,$P(C_2|X)$,\dots,$P(C_m|X)$\}}
            \STATE X$\in$ $C_k$;
\ENDIF
\lastcon ~~\\          %OUTPUT
  X classified to $C_k$;  \hskip 30pt $\rhd$ 最大似然
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]                  %算法的开始
\caption{条件概率的计算}                %算法的标题
\label{alg:Prob}                       %给算法一个标签，这样方便在文中对算法的引用
\begin{algorithmic}[1]                  %不知[1]是干嘛的？
\REQUIRE ~~\\                           %算法的输入参数：Initialization
    $C=\{C_1,C_2,\dots,C_m\}$\hskip 30pt $\rhd$训练样本集
\ENSURE ~~\\                           %算法的迭代：Iteration
    %Ensemble of classifiers on the current batch,  $E_n$;
\FORALL {$j\in m$}
\FORALL {$i\in n$}
 \STATE Compute $P(x_i|C_j)$;
\ENDFOR
\ENDFOR
\lastcon ~~\\          %OUTPUT
$P(C_i|X)$;
\end{algorithmic}
\end{algorithm}

对于一次决策过程，本文提出一个计算公式，来评价一次分配过程，为下一次产生评价因子，首先有如下定义：

\begin{defn}
已知已经产生的分类$C=\{C_1,C_2,\dots,C_n\}$，任务请求编号为$V=\{v_1,v_2,\dots,v_m\}$，定义代价P作为评价标准，定义如下公式：
\end{defn}

\begin{equation}
P=\frac{\sum\limits_{i=1}^m \sum\limits_{j=1}^n T(x_{ij})}{m}
\end{equation}

其中，$T(x_{ij})$满足以下约束：

\begin{equation}
T(x_{ij})=\left\{
\begin{array}{ll}
1,\quad v_j \ \ $属于类i$\\
0,\quad $其它$
\end{array}
\right.
\end{equation}

P值越高代表着决策的正确率越高，如果分类的P值比若干次的值都高，则进行存储交换，用以产生更好的决策。

由于监控器监控的数据有多种，比如CPU使用率、内存使用量、I/O带宽、网络带宽、请求向量等等，所以为了使不同的量纲能够进行比较，就要做出适当的变换，将不同的数据映射到[0,1]区间内。本文采用平移极差变换，假设n个虚拟机，$R_i$表示第i 个虚拟机的资源向量，$R_i$=$\{r_{i1},r_{i2},\dots,r_{in}\}$，变换方法如下：
\begin{equation}
x_{ik}^\prime=\frac{x_{ik}-\min\limits_{1\leq i \leq n}\{x_{ik}\}}{\max\limits_{1\leq i \leq n}\{x_{ik}\}-\min\limits_{1\leq i \leq n}\{x_{ik}\}}
\end{equation}

同理，任务请求的向量也使用平移极差变化得到归一化的值进行计算。
\section{本章小结}
本章分别从原型设计和原型分析两方面阐释了$BMVS^2$的具体细节。第一部分首先从架构图介绍了本系统，并详细介绍了系统的工作流程，继而引出第二节对系统从理论上进行分析。第二节着重从数学方面对分类器和预测器进行了精确的分析，并给出了其工作的伪代码，深入阐述了其实现环节，最后给出了评价准则。
