
\chapter{$BMVS^2$的实现与测试}
\label{chap:sim}
\section{$BMVS^2$的实现}
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.8\textwidth]{optflow}
 \caption{$BMVS^2$执行过程}
 \label{optflow}
\end{figure}

$BMVS^2$的调度实现如\ref{optflow}所示。执行一次这样的流程就相应的完成了一次任务请求的部署操作，任务请求的结构体如下所示，记录了任务的CPU、内存和I/O请求数据，BelongedClass成员代表的是最终划分的类别。
\begin{lstlisting}[frame=lines]
struct Request
{
       double CPU;/*CPU request*/
       double MEM;/*Memory request*/
       double IO; /*IO request*/
       int BelongedClass;
       /*
       remain area
       */
};
\end{lstlisting}

如流程图所示，该流程中的函数解释如下。
\\$\bullet$ \textbf{Bmvs2FetchRequest()}函数

首先，Bmvs2FetchRequest()函数从监控器获得任务请求数据，然后经过平移极差公式（3-7）进行归一化操作，返回一个经过归一化的请求数据。然后，归一化的数据传给分类器函数。

\begin{lstlisting}[frame=lines]
void Bmvs2FetchRequest(int ReqNum,Request *Req,Request *FormattedReq)
{
     //计算平移极差
     int CPU=Max(Req)-Min(Req);
     int IO=Max(Req)-Min(Req);
     int MEM=Max(Req)-Min(Req);
     for(int i=0;i<ReqNum;i++)
     {
             FormattedReq[i].CPU=(FormattedReq[i].CPU-min(Req.CPU))/CPU;
             FormattedReq[i].IO=(FormattedReq[i].IO-min(Req.IO))/IO;
             FormattedReq[i].MEM=(FormattedReq[i].MEM-min(Req.MEM))/MEM;
     }
}
\end{lstlisting}
$\bullet$ \textbf{Bmvs2Classify()}函数

Bmvs2Classify()获取已经预处理的数据，然后从Bmvs2FetchDatabase()函数获得分类标签，分类的结果是给每个人物请求的BelongedClass成员赋值。

\begin{lstlisting}[frame=lines]
     //分类
     O2 = NaiveBayes.fit(Data,Class,'dist',{'kernel','normal','kernel'});
     C2 = O2.predict(Data);
     cMat2 = confusionmat(Dlass,C2);
\end{lstlisting}
\begin{lstlisting}[frame=lines]
void Bmvs2Classify(int ReqNum,Request *FormattedReq)
{
     Bmvs2FetchDatabase();  /*get history data*/
     Classify(FormattedReq);/*make classification*/
     /*store info*/
     for(int i=0;i<ReqNum;i++)
     {
             FormattedReq[i].BelongedClass=BelongedTo[i];
     }
}
\end{lstlisting}
$\bullet$ \textbf{Bmvs2Sched()}函数

BMVS2\_Sched()获得分类的结果，对应各个分类预先设定的调度算法。
\begin{lstlisting}[frame=lines]
void Bmvs2Sched(int ReqNum,Request *FormattedReq)
{
     int CountA=0,CountB=0,CountC=0,CountD=0;
     for(int i=0;i<ReqNum;i++)
     {
             if(FormattedReq[i].BelongedClass==1)
             {
                    A[CountA++].BelongedClass=i;
             }
             ...
             //继续划分其它三类的任务编号
             ...
     }
}
\end{lstlisting}
$\bullet$ \textbf{Bmvs2OptSched()}函数

Bmvs2OptSched()对已经分类好的任务列表调用相应的调度算法。由于任务编号已经在Bmvs2Sched()函数中完成分类记录，所以Bmvs2OptSched()函数直接调用这些算法库中对应的函数实施任务的部署，其中针对4类任务所使用的调度算法是已知的优秀算法，分别为CpuIncentive()、MemIncentive()、IoIncentive()和ShareIncentive()调度函数，分别代表针对CPU密集、内存密集、I/O 密集和普通类任务，过程如下所示。
\begin{lstlisting}[frame=lines]
void Bmvs2OptSched()
{
     /*Task A,B,C,D already exist*/
     CpuIncentive();   /*Deploy A Type Task*/
     MemIncentive();   /*Deploy B Type Task*/
     IoIncentive();    /*Deploy C Type Task*/
     ShareIncentive(); /*Deploy D Type Task*/
}
\end{lstlisting}
$\bullet$ \textbf{Bmvs2ComputeP()}函数

根据公式（3-5），Bmvs2ComputeP()则计算出部署任务后的代价P，即正确分类到预估的类别中的比例，其代码如下所示。
\begin{lstlisting}[frame=lines]
void Bmvs2ComputeP(int ClassNum,int TaskNum)
{
	 for(int i=0;i<ClassNum;i++)
	 {
		 for(int j=0;j<TaskNum;j++)
		 {
			 Profit+=T(i,j);  /*公式3-6*/
		 }
	 }
	 Profit=Profit/TaskNum;
}
\end{lstlisting}
$\bullet$ \textbf{Bmvs2FetchP()}和\textbf{Bmvs2CMPP()}函数

该函数用于从数据库中获取历史代价信息，供Bmvs2CMPP()函数比较，如果新的代价比历史的高，则调用Bmvs2ExchangeData() 函数实施存储交换操作。
\begin{lstlisting}[frame=lines]
void Bmvs2CMPP(double Profit)
{
	/*Fetch Profit from database*/
        int p=Bmvs2FetchP();
        /*Compare profit*/
	if(Profit>p)
	{
	   /*bigger than,do exchange now*/
            Bmvs2ExchangeData();
	}
        /*else return*/
}
\end{lstlisting}
%Weka\cite{Weka}的全名是怀卡托知识分析环境（Waikato Environment for Knowledge Analysis），是一款免费的，基于JAVA 环境下开源的机器学习（Machine Learning）以及数据挖掘（Data Minining）软件。Weka 是新西兰怀卡托大学（University of Waikato）开发的数据挖掘实验平台，目前仍然在项目主页进行维护与更新。Weka的主界面如图\ref{Weka}所示。
 %\begin{figure}[tbh]
 %\centering
 %\includegraphics[width=0.7\textwidth]{Weka}
 %\caption{Weka知识分析软件的主界面}
 %\label{Weka}
%\end{figure}

\section{$BMVS^2$的测试}
\subsection{测试环境}
本系统的测试环境如表\ref{environment}所示。其中Weka\cite{Weka}的全名是怀卡托知识分析环境（Waikato Environment for Knowledge Analysis），是一款免费的，基于JAVA 环境下开源的机器学习（Machine Learning）以及数据挖掘（Data Minining）软件。Weka 是新西兰怀卡托大学（University of Waikato）开发的数据挖掘实验平台，目前仍然在项目主页进行维护与更新。
\begin{table}[tbh]
\centering
\caption{\label{environment} $BMVS^2$测试环境}

\begin{tabular}{l|l}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  硬件平台& \ \ Lenovo$^\circledR$ Y450 T6600 2.1GHz,2GB RAM \\
  \hline
  软件平台 & \begin{tabular}{l}
              Microsoft$^\circledR$ Windows$^\circledR$ 7 SP1 32bit（English） \\
              Weka Machine Learning Software V3 \\
              Microsoft$^\circledR$ Visual Studio$^\circledR$ 2010 Ultimate \\
              Matlab$^\circledR$ R2012a\\
             \end{tabular}
  \\ \hline
\end{tabular}
\end{table}
\subsection{任务概述}
本实验对三种不同的资源权值分布特征进行分类，假设监控的数据分别是$R_i$=$\{r_{i1},r_{i2},\dots,r_{in}\}$，这三种权值\cite{dataclass}分别是：

（1）$d_1$=0.8，$d_2$=$d_3$=0.05

（2）$d_1$=0.6，$d_2$=$d_3$=0.1

（3）$d_1$=0.4，$d_2$=$d_3$=0.15

（4）$d_1$=0.2，$d_2$=0.2，$d_3$=0.3

（5）$d_1$=0.1，$d_2$=0.5，$d_3$=0.1

对于第（1）类，表示计算密集型的任务居多，如数值计算、数据挖掘分析等；第（2）、（3）类表示需求均衡类的任务表示，其中第（2）类CPU资源需求强于其它类的计算任务；第（4）类表示I/O型任务；第（5）类表示内存需求较高的任务，Weka的聚类分析如图\ref{cluster}所示。
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.8\textwidth]{cluster}
 \caption{Weka聚类分析结果}
 \label{cluster}
\end{figure}
\subsection{测试结果}
通过Weka聚类分析，我们获得一个较理想的、符合实际意义的数据分布图，其任务需求曲线如图\ref{dataset2}所示，其中图（a）表示的是CPU需求曲线，可以看出，CPU需求大部分出去中间段，极端情况只有少量的分布；图（b）代表内存分布，相比CPU 分布，内存处于中间部分的样本更多；I/O分布呈现出了较随机的分布，但是极端情况也很少发生，这与\cite{intro_DRF} 中Facebook实际测试分布图的情况大致相同，说明该图是符合实际情况的；图（d）用盒图表示了CPU、内存和I/O请求的大部分数据的分布情况。
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=1.0\textwidth]{dataset2}
 \caption{典型的虚拟环境下任务曲线}
 \label{dataset2}
\end{figure}

由如下公式可计算出分类的先验概率：

\begin{equation}
P(c)=\frac{NumOf(c)}{Total};c \in\{A,B,C\}
\end{equation}

因此，P（A）=0.16，P（B）=0.05，P（C）=0.09，P（D）=0.70。测试中分别以1、2、3、4代表A、B、C、D类别，如图\ref{bayes1} 所示的是由100 组数据训练的结果。其中柱状图中的矩阵代表的是分类后的混淆矩阵，表示了正确分类与否的任务个数；以第4 类为例，从左向右依次为正确分类到第4类的66个样本，错误的分给第1类的1个、第2类2个、第3类1个；右图直观上给出了任务在空间上的分布情况。
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=1.0\textwidth]{bayes1}
 \caption{由测试数据集而得的分类结果}
 \label{bayes1}
\end{figure}

如图\ref{bayes2}所示，测试100组任务请求数据而得到的数据。同图\ref{bayes1}，该图也使用了矩阵和立体图给出详细的任务分布。
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=1.0\textwidth]{bayes2}
 \caption{对100组任务请求数据集分类的结果}
 \label{bayes2}
\end{figure}

从图中可以看出，任务分布也遵从类似高斯分布的特征，对资源需求密集的任务属于少数，大多数任务属于普通类。利用公式（3-5）可以求得正确分类的百分比。同时，该矩阵还用来求得下一节定义的收益函数。
\subsection{测试结果评估分析}
分类后的任务请求，经过一个重新组合的过程，可以形成一个更优的组态。然后在此基础上重新分配任务请求的去向，如图\ref{recombin}所示。
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.9\textwidth]{recombin}
 \caption{分类后的任务请求分配过程}
 \label{recombin}
\end{figure}

假设虚拟环境下有多种任务，也有多种任务分配算法。而目前的算法都有针对的特定应用环境，比如LRU解决CPU密集型、带有BOOST 特性的Credit算法具有针对I/O的优化、DRF算法具有公平的性质，能够最大化的共享资源、针对内存优化的调度算法。

\begin{defn}
每类算法对其特定的情况，定义其收益为1，否则收益为0.8，忽略请求列表的变更代价。假设有n个任务请求$t$=$\{t_1,t_2,\dots,t_n\}$，收益函数定义如公式\ref{profit}所示。
\end{defn}

\begin{equation}
\label{profit}
Cost=\sum\limits_{i=1}^n T(i)
\end{equation}

其中：

\begin{equation}
T(i)=\left\{
\begin{array}{ll}
1,\quad \ \ $适用于任务i的算法$\\
0.8,\quad $其它$
\end{array}
\right.
\end{equation}

则单一调度分配算法平台的收益和$BMVS^2$收益的对比如图\ref{CMP}所示：

 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.85\textwidth]{CMP}
 \caption{单一调度分配算法和$BMVS^2$的收益对比}
 \label{CMP}
\end{figure}

如图\ref{CMP}所示，$BMVS^2$有着更高的收益，代表着有更高的系统平均利用率。A、B、C、D分别有着83.2、81、81.8、94 的收益，而本文提出的$BMVS^2$有着96.4的收益，而且随着任务请求曲线（类高斯分布曲线）的逐渐平坦，$BMVS^2$会获得更高的收益，如图\ref{CMP2}所示。

 \begin{figure}[tbh]
 \centering
 \includegraphics[width=0.85\textwidth]{CMP2}
 \caption{单一调度分配算法和$BMVS^2$的收益对比（随着资源分布的均衡）}
 \label{CMP2}
\end{figure}
\subsection{结论}
从实验的数据我们可以看出，根据不同的任务请求，结合不同算法的不同标准得到一个最优的部署是可能和合理的。而且这种需求是现实存在的，我们可以通过这种组合获得性能上的提升、体系架构的智能化发展等等。

通过实验可知，针对不同的应用背景，使用合适的算法进行调度是比原有策略更好的一个决策。
\section{本章小结}
本章分别介绍了系统实现，测试的软硬件平台，测试过程。通过测试得到的数据和图表，从实验角度分析了系统的可行性，并对本系统的核心模块― 预测和分类模块同以往没有使用融合预测调度的系统收益进行了比较，评估了测试结果，并获得了预期的结果。最后对本次测试做出了总结。
